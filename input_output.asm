.model SMALL
.stack
.data

CHAR DB 'J'
STR DB 'Hello world', 10, 13, '$' ;10 -> NEW LINE, 13 -> ALIGN LEFT, $-> END OF STR

VAR DB ?
BUFFER DB 31, 32 DUP(?)

.code
.startup

;|---PRINT STRING---|

MOV DX, OFFSET STR
MOV AH, 09
INT 21H 

;MOV AX, OFFSET STR
;PUSH AX
;CALL PRINT_STR
;POP AX


;|---PRINT CHAR---|

MOV DL, CHAR
MOV AH, 02
INT 21H

;MOV AX, WORD PTR CHAR
;PUSH AX
;CALL PRINT_CHAR
;POP AX


;|---INPUT CHAR---|
MOV AH, 01
INT 21H ;AL WILL CONTAIN THE INPUT CHAR
MOV VAR, AL


;|---INPUT STRING---|

MOV BX, OFFSET BUFFER
MOV DX, BX

MOV BYTE[BX], 33 ;PUTTING 33 (32 CHAR + ENTER KEY) ON THE FIRST BYTE OF THE BUFFER. SERVICE 0AH NEED TO KNOW LENGTH OF STRING
MOV AH, 0AH
INT 21H

MOV BX, OFFSET BUFFER
MOV AL, [BX+1] ;AL NOW CONTAINS THE ACTUAL LENGTH OF THE STRING
ADD AL, 2
MOV AH, 0
MOV SI, AX
MOV BYTE[BX+SI], '$' ;PUTTING END OF STRING

MOV DX, OFFSET BUFFER
ADD DX, 2
MOV AH, 09
INT 21H ;OUTPUT OF THE STRING
               

.exit

PRINT_STR PROC NEAR
    PUSH BP
    MOV BP, SP
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV DX, [BP+4]
    MOV AH, 9
    INT 21H
    
    POP DX
    POP CX
    POP BX
    POP AX
    POP BP
    RET
PRINT_STR ENDP

PRINT_CHAR PROC NEAR
    PUSH BP
    MOV BP, SP
    PUSH AX
    PUSH BX
    PUSH CX
    PUSH DX
    
    MOV DL, [BP+4]
    MOV AH, 2
    INT 21H
    
    POP DX
    POP CX
    POP BX
    POP AX
    POP BP
    RET
PRINT_CHAR ENDP

end